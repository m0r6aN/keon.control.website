{"version":3,"sources":["../../../../node_modules/next/src/server/route-modules/app-page/module.compiled.js","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","../../../../src/lib/incident-mode.tsx","../../../../src/components/providers.tsx","../../../../src/lib/state/context.tsx","../../../../src/lib/api/config.ts","../../../../src/lib/api/errors.ts","../../../../src/lib/api/client.ts","../../../../src/lib/api/receipts.ts","../../../../src/lib/api/executions.ts","../../../../src/lib/api/traces.ts","../../../../src/lib/api/alerts.ts","../../../../src/lib/api/policies.ts","../../../../src/lib/api/tenants.ts","../../../../src/lib/state/hooks.ts"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","\"use client\";\n\nimport * as React from \"react\";\n\n/**\n * INCIDENT MODE â€” State of Being\n * \n * This is not a theme. This is not a toggle.\n * When Incident Mode activates, the UI seizes control.\n */\n\nexport type IncidentSeverity = \"critical\" | \"high\" | \"medium\";\n\nexport interface IncidentEvent {\n  id: string;\n  timestamp: string;\n  subsystem: string;\n  action: string;\n  severity: \"critical\" | \"warning\" | \"info\";\n  policyRef?: string;\n  receiptHash?: string;\n  actor?: string;\n  schemaVersion?: \"v1\";\n}\n\nexport interface LastIrreversibleAction {\n  timestamp: string;\n  actor: string;\n  receiptHashPrefix: string;\n  action: string;\n}\n\nexport interface HumanInLoopStatus {\n  acknowledged: string[];\n  missing: string[];\n  slaDeadline: string;\n}\n\nexport interface IncidentState {\n  active: boolean;\n  incidentId: string | null;\n  severity: IncidentSeverity | null;\n  startedAt: string | null;\n  trustScore: number;\n  trustScoreThreshold: number;\n  rootSubsystem: string | null;\n  impactedComponents: string[];\n  activePolicies: string[];\n  quorumState: \"met\" | \"pending\" | \"failed\";\n  events: IncidentEvent[];\n  lastIrreversibleAction: LastIrreversibleAction | null;\n  humanInLoop: HumanInLoopStatus;\n  exitConditionsMet: boolean;\n}\n\ninterface IncidentContextValue {\n  state: IncidentState;\n  activateIncident: (params: {\n    incidentId: string;\n    severity: IncidentSeverity;\n    rootSubsystem: string;\n    impactedComponents?: string[];\n  }) => void;\n  deactivateIncident: () => void;\n  addEvent: (event: Omit<IncidentEvent, \"id\" | \"timestamp\">) => void;\n  updateTrustScore: (score: number) => void;\n  acknowledgeHuman: (humanId: string) => void;\n  checkExitConditions: () => boolean;\n}\n\nconst defaultState: IncidentState = {\n  active: false,\n  incidentId: null,\n  severity: null,\n  startedAt: null,\n  trustScore: 100,\n  trustScoreThreshold: 70,\n  rootSubsystem: null,\n  impactedComponents: [],\n  activePolicies: [],\n  quorumState: \"met\",\n  events: [],\n  lastIrreversibleAction: null,\n  humanInLoop: {\n    acknowledged: [],\n    missing: [\"operator-1\", \"operator-2\"],\n    slaDeadline: new Date(Date.now() + 15 * 60 * 1000).toISOString(),\n  },\n  exitConditionsMet: false,\n};\n\nconst IncidentContext = React.createContext<IncidentContextValue | null>(null);\n\nexport function IncidentModeProvider({ children }: { children: React.ReactNode }) {\n  const [state, setState] = React.useState<IncidentState>(defaultState);\n\n  const activateIncident = React.useCallback(\n    (params: {\n      incidentId: string;\n      severity: IncidentSeverity;\n      rootSubsystem: string;\n      impactedComponents?: string[];\n    }) => {\n      setState((prev) => ({\n        ...prev,\n        active: true,\n        incidentId: params.incidentId,\n        severity: params.severity,\n        startedAt: new Date().toISOString(),\n        rootSubsystem: params.rootSubsystem,\n        impactedComponents: params.impactedComponents ?? [],\n        exitConditionsMet: false,\n      }));\n    },\n    []\n  );\n\n  const deactivateIncident = React.useCallback(() => {\n    setState((prev) => {\n      if (!prev.exitConditionsMet) return prev;\n      return { ...defaultState };\n    });\n  }, []);\n\n  const addEvent = React.useCallback(\n    (event: Omit<IncidentEvent, \"id\" | \"timestamp\">) => {\n      const newEvent: IncidentEvent = {\n        ...event,\n        id: `evt_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,\n        timestamp: new Date().toISOString(),\n        schemaVersion: \"v1\",\n      };\n      setState((prev) => ({\n        ...prev,\n        events: [...prev.events, newEvent],\n      }));\n    },\n    []\n  );\n\n  const updateTrustScore = React.useCallback((score: number) => {\n    setState((prev) => ({ ...prev, trustScore: score }));\n  }, []);\n\n  const acknowledgeHuman = React.useCallback(\n    (humanId: string) => {\n      // Update HITL lists\n      setState((prev) => ({\n        ...prev,\n        humanInLoop: {\n          ...prev.humanInLoop,\n          acknowledged: prev.humanInLoop.acknowledged.includes(humanId)\n            ? prev.humanInLoop.acknowledged\n            : [...prev.humanInLoop.acknowledged, humanId],\n          missing: prev.humanInLoop.missing.filter((h) => h !== humanId),\n        },\n      }));\n\n      // Record a court-grade event for the acknowledgment so it shows up\n      // in the Evidence Timeline and derived views (e.g. \"Last Human Action\").\n      addEvent({\n        subsystem: \"human-operator\",\n        action: \"operator.acknowledged.incident\",\n        severity: \"info\",\n        actor: humanId,\n      });\n    },\n    [addEvent]\n  );\n\n  const checkExitConditions = React.useCallback(() => {\n    const noRedEvents = !state.events.some((e) => e.severity === \"critical\");\n    const trustStable = state.trustScore >= state.trustScoreThreshold;\n    const met = noRedEvents && trustStable;\n    if (met !== state.exitConditionsMet) {\n      setState((prev) => ({ ...prev, exitConditionsMet: met }));\n    }\n    return met;\n  }, [state.events, state.trustScore, state.trustScoreThreshold, state.exitConditionsMet]);\n\n  return (\n    <IncidentContext.Provider\n      value={{\n        state,\n        activateIncident,\n        deactivateIncident,\n        addEvent,\n        updateTrustScore,\n        acknowledgeHuman,\n        checkExitConditions,\n      }}\n    >\n      {children}\n    </IncidentContext.Provider>\n  );\n}\n\nexport function useIncidentMode() {\n  const ctx = React.useContext(IncidentContext);\n  if (!ctx) throw new Error(\"useIncidentMode must be used within IncidentModeProvider\");\n  return ctx;\n}\n\n","\"use client\";\n\nimport * as React from \"react\";\nimport { IncidentModeProvider } from \"@/lib/incident-mode\";\nimport { AppStateProvider } from \"@/lib/state\";\nimport { getApiConfig } from \"@/lib/api\";\n\n/**\n * GLOBAL PROVIDERS\n *\n * Wraps the application with all necessary context providers.\n * Order matters - app state should be at the root, then incident mode.\n */\nexport function Providers({ children }: { children: React.ReactNode }) {\n  const apiConfig = getApiConfig();\n\n  return (\n    <AppStateProvider initialState={{ liveMode: apiConfig.liveMode }}>\n      <IncidentModeProvider>\n        {children}\n      </IncidentModeProvider>\n    </AppStateProvider>\n  );\n}\n\n","/**\r\n * Global State Context\r\n * Lightweight state management for shared app data\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport type { SystemMetrics } from '@/lib/api';\r\n\r\nexport interface AppState {\r\n  /**\r\n   * Current tenant ID (for multi-tenancy)\r\n   */\r\n  tenantId: string | null;\r\n\r\n  /**\r\n   * System-wide metrics\r\n   */\r\n  systemMetrics: SystemMetrics | null;\r\n\r\n  /**\r\n   * Whether the app is in \"live mode\" (real API) vs \"mock mode\"\r\n   */\r\n  liveMode: boolean;\r\n\r\n  /**\r\n   * Global loading state\r\n   */\r\n  isLoading: boolean;\r\n\r\n  /**\r\n   * Global error state\r\n   */\r\n  error: Error | null;\r\n}\r\n\r\nexport interface AppActions {\r\n  setTenantId: (tenantId: string | null) => void;\r\n  setSystemMetrics: (metrics: SystemMetrics | null) => void;\r\n  setLiveMode: (enabled: boolean) => void;\r\n  setLoading: (loading: boolean) => void;\r\n  setError: (error: Error | null) => void;\r\n  clearError: () => void;\r\n}\r\n\r\nexport type AppContext = AppState & AppActions;\r\n\r\nconst AppStateContext = React.createContext<AppContext | null>(null);\r\n\r\n/**\r\n * Default state values\r\n */\r\nconst defaultState: AppState = {\r\n  tenantId: null,\r\n  systemMetrics: null,\r\n  liveMode: false,\r\n  isLoading: false,\r\n  error: null,\r\n};\r\n\r\nexport interface AppStateProviderProps {\r\n  children: React.ReactNode;\r\n  initialState?: Partial<AppState>;\r\n}\r\n\r\n/**\r\n * App State Provider\r\n */\r\nexport function AppStateProvider({ children, initialState }: AppStateProviderProps) {\r\n  const [state, setState] = React.useState<AppState>({\r\n    ...defaultState,\r\n    ...initialState,\r\n  });\r\n\r\n  const actions: AppActions = React.useMemo(\r\n    () => ({\r\n      setTenantId: (tenantId) => setState((s) => ({ ...s, tenantId })),\r\n      setSystemMetrics: (systemMetrics) => setState((s) => ({ ...s, systemMetrics })),\r\n      setLiveMode: (liveMode) => setState((s) => ({ ...s, liveMode })),\r\n      setLoading: (isLoading) => setState((s) => ({ ...s, isLoading })),\r\n      setError: (error) => setState((s) => ({ ...s, error })),\r\n      clearError: () => setState((s) => ({ ...s, error: null })),\r\n    }),\r\n    []\r\n  );\r\n\r\n  const contextValue: AppContext = React.useMemo(\r\n    () => ({\r\n      ...state,\r\n      ...actions,\r\n    }),\r\n    [state, actions]\r\n  );\r\n\r\n  return <AppStateContext.Provider value={contextValue}>{children}</AppStateContext.Provider>;\r\n}\r\n\r\n/**\r\n * Hook to access app state and actions\r\n */\r\nexport function useAppState(): AppContext {\r\n  const context = React.useContext(AppStateContext);\r\n\r\n  if (!context) {\r\n    throw new Error('useAppState must be used within AppStateProvider');\r\n  }\r\n\r\n  return context;\r\n}\r\n","/**\r\n * API Configuration\r\n * Centralized configuration for KEON Control API\r\n */\r\n\r\nexport interface ApiConfig {\r\n  /**\r\n   * Base URL for the API (e.g., \"http://localhost:5000\")\r\n   */\r\n  baseUrl: string;\r\n\r\n  /**\r\n   * Default request timeout in milliseconds\r\n   */\r\n  timeout: number;\r\n\r\n  /**\r\n   * Whether to use mock data as fallback when API is unavailable\r\n   */\r\n  useMockFallback: boolean;\r\n\r\n  /**\r\n   * Whether API is in \"live mode\" (actual backend) vs \"mock mode\"\r\n   */\r\n  liveMode: boolean;\r\n}\r\n\r\n/**\r\n * Get API configuration from environment variables\r\n */\r\nexport function getApiConfig(): ApiConfig {\r\n  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';\r\n  const timeout = parseInt(process.env.NEXT_PUBLIC_API_TIMEOUT || '10000', 10);\r\n  const useMockFallback = process.env.NEXT_PUBLIC_API_USE_MOCK_FALLBACK !== 'false';\r\n  const liveMode = process.env.NEXT_PUBLIC_API_LIVE_MODE === 'true';\r\n\r\n  return {\r\n    baseUrl,\r\n    timeout,\r\n    useMockFallback,\r\n    liveMode,\r\n  };\r\n}\r\n\r\n/**\r\n * Default API configuration\r\n */\r\nexport const defaultApiConfig: ApiConfig = getApiConfig();\r\n","/**\r\n * API Error Types\r\n * Centralized error handling for KEON Control API\r\n */\r\n\r\nexport class ApiError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public statusCode?: number,\r\n    public code?: string,\r\n    public details?: unknown\r\n  ) {\r\n    super(message);\r\n    this.name = 'ApiError';\r\n  }\r\n}\r\n\r\nexport class NetworkError extends ApiError {\r\n  constructor(message: string, details?: unknown) {\r\n    super(message, undefined, 'NETWORK_ERROR', details);\r\n    this.name = 'NetworkError';\r\n  }\r\n}\r\n\r\nexport class TimeoutError extends ApiError {\r\n  constructor(message: string) {\r\n    super(message, undefined, 'TIMEOUT_ERROR');\r\n    this.name = 'TimeoutError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends ApiError {\r\n  constructor(message: string, details?: unknown) {\r\n    super(message, 400, 'VALIDATION_ERROR', details);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class NotFoundError extends ApiError {\r\n  constructor(message: string) {\r\n    super(message, 404, 'NOT_FOUND');\r\n    this.name = 'NotFoundError';\r\n  }\r\n}\r\n\r\nexport class UnauthorizedError extends ApiError {\r\n  constructor(message: string) {\r\n    super(message, 401, 'UNAUTHORIZED');\r\n    this.name = 'UnauthorizedError';\r\n  }\r\n}\r\n\r\nexport class ServerError extends ApiError {\r\n  constructor(message: string, statusCode: number, details?: unknown) {\r\n    super(message, statusCode, 'SERVER_ERROR', details);\r\n    this.name = 'ServerError';\r\n  }\r\n}\r\n\r\n/**\r\n * Parse API error response\r\n */\r\nexport function parseApiError(error: unknown): ApiError {\r\n  if (error instanceof ApiError) {\r\n    return error;\r\n  }\r\n\r\n  if (error instanceof TypeError && error.message.includes('fetch')) {\r\n    return new NetworkError('Network request failed. Check your connection and ensure the API is running.');\r\n  }\r\n\r\n  if (error instanceof Error) {\r\n    return new ApiError(error.message);\r\n  }\r\n\r\n  return new ApiError('An unknown error occurred');\r\n}\r\n","/**\r\n * API Client\r\n * Base HTTP client for KEON Control API with error handling and correlation ID support\r\n */\r\n\r\nimport { defaultApiConfig, type ApiConfig } from './config';\r\nimport {\r\n  ApiError,\r\n  NetworkError,\r\n  NotFoundError,\r\n  ServerError,\r\n  TimeoutError,\r\n  UnauthorizedError,\r\n  ValidationError,\r\n  parseApiError,\r\n} from './errors';\r\n\r\nexport interface RequestOptions {\r\n  /**\r\n   * HTTP method (default: GET)\r\n   */\r\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\r\n\r\n  /**\r\n   * Request body (will be JSON stringified)\r\n   */\r\n  body?: unknown;\r\n\r\n  /**\r\n   * Additional headers\r\n   */\r\n  headers?: Record<string, string>;\r\n\r\n  /**\r\n   * Query parameters\r\n   */\r\n  params?: Record<string, string | number | boolean | undefined | null>;\r\n\r\n  /**\r\n   * Request timeout (overrides default)\r\n   */\r\n  timeout?: number;\r\n\r\n  /**\r\n   * Correlation ID for request tracing\r\n   */\r\n  correlationId?: string;\r\n\r\n  /**\r\n   * Tenant ID for multi-tenant requests\r\n   */\r\n  tenantId?: string;\r\n}\r\n\r\nexport interface ApiResponse<T> {\r\n  data: T;\r\n  statusCode: number;\r\n  headers: Headers;\r\n}\r\n\r\n/**\r\n * Generate a correlation ID for request tracing\r\n */\r\nfunction generateCorrelationId(): string {\r\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Build URL with query parameters\r\n */\r\nfunction buildUrl(baseUrl: string, path: string, params?: Record<string, string | number | boolean | undefined | null>): string {\r\n  const url = new URL(path, baseUrl);\r\n\r\n  if (params) {\r\n    Object.entries(params).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null) {\r\n        url.searchParams.append(key, String(value));\r\n      }\r\n    });\r\n  }\r\n\r\n  return url.toString();\r\n}\r\n\r\n/**\r\n * Create fetch with timeout\r\n */\r\nfunction fetchWithTimeout(url: string, options: RequestInit, timeoutMs: number): Promise<Response> {\r\n  return new Promise((resolve, reject) => {\r\n    const timeoutId = setTimeout(() => {\r\n      reject(new TimeoutError(`Request timeout after ${timeoutMs}ms`));\r\n    }, timeoutMs);\r\n\r\n    fetch(url, options)\r\n      .then((response) => {\r\n        clearTimeout(timeoutId);\r\n        resolve(response);\r\n      })\r\n      .catch((error) => {\r\n        clearTimeout(timeoutId);\r\n        reject(error);\r\n      });\r\n  });\r\n}\r\n\r\n/**\r\n * Parse response based on content type\r\n */\r\nasync function parseResponse<T>(response: Response): Promise<T> {\r\n  const contentType = response.headers.get('content-type');\r\n\r\n  if (contentType?.includes('application/json')) {\r\n    return response.json();\r\n  }\r\n\r\n  if (contentType?.includes('text/')) {\r\n    return response.text() as T;\r\n  }\r\n\r\n  // For binary data or unknown content types\r\n  return response.blob() as T;\r\n}\r\n\r\n/**\r\n * Handle HTTP errors\r\n */\r\nasync function handleErrorResponse(response: Response): Promise<never> {\r\n  let errorMessage = `Request failed with status ${response.status}`;\r\n  let errorDetails: unknown;\r\n\r\n  try {\r\n    const contentType = response.headers.get('content-type');\r\n    if (contentType?.includes('application/json')) {\r\n      const errorData = await response.json();\r\n      errorMessage = errorData.error || errorData.message || errorMessage;\r\n      errorDetails = errorData;\r\n    } else {\r\n      errorMessage = await response.text() || errorMessage;\r\n    }\r\n  } catch {\r\n    // If error response parsing fails, use default message\r\n  }\r\n\r\n  switch (response.status) {\r\n    case 400:\r\n      throw new ValidationError(errorMessage, errorDetails);\r\n    case 401:\r\n      throw new UnauthorizedError(errorMessage);\r\n    case 404:\r\n      throw new NotFoundError(errorMessage);\r\n    case 500:\r\n    case 502:\r\n    case 503:\r\n    case 504:\r\n      throw new ServerError(errorMessage, response.status, errorDetails);\r\n    default:\r\n      throw new ApiError(errorMessage, response.status, undefined, errorDetails);\r\n  }\r\n}\r\n\r\n/**\r\n * KEON Control API Client\r\n */\r\nexport class ApiClient {\r\n  private config: ApiConfig;\r\n\r\n  constructor(config: ApiConfig = defaultApiConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Make an HTTP request to the API\r\n   */\r\n  async request<T>(path: string, options: RequestOptions = {}): Promise<ApiResponse<T>> {\r\n    const {\r\n      method = 'GET',\r\n      body,\r\n      headers = {},\r\n      params,\r\n      timeout = this.config.timeout,\r\n      correlationId = generateCorrelationId(),\r\n      tenantId,\r\n    } = options;\r\n\r\n    const url = buildUrl(this.config.baseUrl, path, params);\r\n\r\n    const requestHeaders: Record<string, string> = {\r\n      'Content-Type': 'application/json',\r\n      'X-Correlation-Id': correlationId,\r\n      ...headers,\r\n    };\r\n\r\n    if (tenantId) {\r\n      requestHeaders['X-Tenant-Id'] = tenantId;\r\n    }\r\n\r\n    const requestInit: RequestInit = {\r\n      method,\r\n      headers: requestHeaders,\r\n      body: body ? JSON.stringify(body) : undefined,\r\n    };\r\n\r\n    try {\r\n      const response = await fetchWithTimeout(url, requestInit, timeout);\r\n\r\n      if (!response.ok) {\r\n        await handleErrorResponse(response);\r\n      }\r\n\r\n      const data = await parseResponse<T>(response);\r\n\r\n      return {\r\n        data,\r\n        statusCode: response.status,\r\n        headers: response.headers,\r\n      };\r\n    } catch (error) {\r\n      throw parseApiError(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * GET request\r\n   */\r\n  async get<T>(path: string, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<T> {\r\n    const response = await this.request<T>(path, { ...options, method: 'GET' });\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * POST request\r\n   */\r\n  async post<T>(path: string, body?: unknown, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<T> {\r\n    const response = await this.request<T>(path, { ...options, method: 'POST', body });\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * PUT request\r\n   */\r\n  async put<T>(path: string, body?: unknown, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<T> {\r\n    const response = await this.request<T>(path, { ...options, method: 'PUT', body });\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * DELETE request\r\n   */\r\n  async delete<T>(path: string, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<T> {\r\n    const response = await this.request<T>(path, { ...options, method: 'DELETE' });\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * PATCH request\r\n   */\r\n  async patch<T>(path: string, body?: unknown, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<T> {\r\n    const response = await this.request<T>(path, { ...options, method: 'PATCH', body });\r\n    return response.data;\r\n  }\r\n}\r\n\r\n/**\r\n * Default API client instance\r\n */\r\nexport const apiClient = new ApiClient();\r\n","/**\r\n * Receipts API Client\r\n */\r\n\r\nimport { apiClient } from './client';\r\nimport type { ReceiptEnvelope, ReceiptPage } from './types';\r\n\r\nexport interface ListReceiptsOptions {\r\n  tenantId?: string;\r\n  correlationId: string;\r\n  kind?: 'decision' | 'execution' | 'memory';\r\n  pageToken?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport interface GetReceiptOptions {\r\n  receiptId: string;\r\n  correlationId: string;\r\n}\r\n\r\n/**\r\n * List receipts with filtering\r\n */\r\nexport async function listReceipts(options: ListReceiptsOptions): Promise<ReceiptPage> {\r\n  const { tenantId, correlationId, kind, pageToken, limit } = options;\r\n\r\n  return apiClient.get<ReceiptPage>('/governance/receipts', {\r\n    params: {\r\n      tenantId,\r\n      correlationId,\r\n      kind,\r\n      pageToken,\r\n      limit,\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Get a single receipt by ID\r\n */\r\nexport async function getReceipt(options: GetReceiptOptions): Promise<ReceiptEnvelope> {\r\n  const { receiptId, correlationId } = options;\r\n\r\n  return apiClient.get<ReceiptEnvelope>(`/governance/receipts/${receiptId}`, {\r\n    params: {\r\n      correlationId,\r\n    },\r\n  });\r\n}\r\n","/**\r\n * Executions API Client\r\n */\r\n\r\nimport { apiClient } from './client';\r\nimport type { ExecutionPage, ExecutionResult, ExecutionTraceEvent } from './types';\r\n\r\nexport interface ListExecutionsOptions {\r\n  tenantId?: string;\r\n  correlationId: string;\r\n  pageToken?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport interface GetExecutionOptions {\r\n  executionId: string;\r\n  correlationId: string;\r\n}\r\n\r\n/**\r\n * List executions with filtering\r\n */\r\nexport async function listExecutions(options: ListExecutionsOptions): Promise<ExecutionPage> {\r\n  const { tenantId, correlationId, pageToken, limit } = options;\r\n\r\n  return apiClient.get<ExecutionPage>('/runtime/executions', {\r\n    params: {\r\n      tenantId,\r\n      correlationId,\r\n      pageToken,\r\n      limit,\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Get a single execution by ID\r\n */\r\nexport async function getExecution(options: GetExecutionOptions): Promise<ExecutionResult> {\r\n  const { executionId, correlationId } = options;\r\n\r\n  return apiClient.get<ExecutionResult>(`/runtime/executions/${executionId}`, {\r\n    params: {\r\n      correlationId,\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Get trace events for an execution\r\n */\r\nexport async function getExecutionTrace(options: GetExecutionOptions): Promise<ExecutionTraceEvent[]> {\r\n  const { executionId, correlationId } = options;\r\n\r\n  return apiClient.get<ExecutionTraceEvent[]>(`/runtime/executions/${executionId}/trace`, {\r\n    params: {\r\n      correlationId,\r\n    },\r\n  });\r\n}\r\n","/**\r\n * Traces (Observability) API Client\r\n */\r\n\r\nimport { apiClient } from './client';\r\nimport type { ReceiptSpine, CorrelationPage, CorrelationSummary } from './types';\r\n\r\nexport interface GetSpineOptions {\r\n  correlationId: string;\r\n}\r\n\r\nexport interface ListCorrelationsOptions {\r\n  tenantId: string;\r\n  from?: string;\r\n  to?: string;\r\n  pageToken?: string;\r\n}\r\n\r\n/**\r\n * Get receipt spine (graph) for a correlation ID\r\n */\r\nexport async function getSpine(options: GetSpineOptions): Promise<ReceiptSpine> {\r\n  const { correlationId } = options;\r\n\r\n  return apiClient.get<ReceiptSpine>(`/observability/spines/${correlationId}`);\r\n}\r\n\r\n/**\r\n * List correlations for a tenant\r\n */\r\nexport async function listCorrelations(options: ListCorrelationsOptions): Promise<CorrelationPage> {\r\n  const { tenantId, from, to, pageToken } = options;\r\n\r\n  return apiClient.get<CorrelationPage>('/observability/correlations', {\r\n    params: {\r\n      tenantId,\r\n      from,\r\n      to,\r\n      pageToken,\r\n    },\r\n  });\r\n}\r\n","/**\r\n * Alerts API Client\r\n * Note: Backend endpoint stub - will be implemented later\r\n */\r\n\r\nimport { apiClient } from './client';\r\nimport type { Alert } from './types';\r\n\r\nexport interface ListAlertsOptions {\r\n  tenantId?: string;\r\n  severity?: 'info' | 'warning' | 'error' | 'critical';\r\n  acknowledged?: boolean;\r\n  limit?: number;\r\n}\r\n\r\nexport interface AcknowledgeAlertOptions {\r\n  alertId: string;\r\n}\r\n\r\n/**\r\n * List alerts with filtering\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function listAlerts(options: ListAlertsOptions = {}): Promise<Alert[]> {\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.get<Alert[]>('/alerts', { params: options });\r\n\r\n  throw new Error('Alerts API endpoint not yet implemented in backend');\r\n}\r\n\r\n/**\r\n * Acknowledge an alert\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function acknowledgeAlert(options: AcknowledgeAlertOptions): Promise<Alert> {\r\n  const { alertId } = options;\r\n\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.post<Alert>(`/alerts/${alertId}/acknowledge`);\r\n\r\n  throw new Error('Alerts API endpoint not yet implemented in backend');\r\n}\r\n\r\n/**\r\n * Acknowledge all alerts\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function acknowledgeAllAlerts(): Promise<void> {\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.post<void>('/alerts/acknowledge-all');\r\n\r\n  throw new Error('Alerts API endpoint not yet implemented in backend');\r\n}\r\n","/**\r\n * Policies API Client\r\n * Note: Backend endpoint stub - will be implemented later\r\n */\r\n\r\nimport { apiClient } from './client';\r\nimport type { Policy } from './types';\r\n\r\nexport interface ListPoliciesOptions {\r\n  tenantId?: string;\r\n  enabled?: boolean;\r\n  limit?: number;\r\n}\r\n\r\nexport interface GetPolicyOptions {\r\n  policyId: string;\r\n}\r\n\r\n/**\r\n * List policies with filtering\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function listPolicies(options: ListPoliciesOptions = {}): Promise<Policy[]> {\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.get<Policy[]>('/policies', { params: options });\r\n\r\n  throw new Error('Policies API endpoint not yet implemented in backend');\r\n}\r\n\r\n/**\r\n * Get a single policy by ID\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function getPolicy(options: GetPolicyOptions): Promise<Policy> {\r\n  const { policyId } = options;\r\n\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.get<Policy>(`/policies/${policyId}`);\r\n\r\n  throw new Error('Policies API endpoint not yet implemented in backend');\r\n}\r\n","/**\r\n * Tenants API Client\r\n * Note: Backend endpoint stub - will be implemented later\r\n */\r\n\r\nimport { apiClient } from './client';\r\nimport type { Tenant } from './types';\r\n\r\nexport interface ListTenantsOptions {\r\n  status?: 'active' | 'inactive' | 'suspended';\r\n  limit?: number;\r\n}\r\n\r\nexport interface GetTenantOptions {\r\n  tenantId: string;\r\n}\r\n\r\n/**\r\n * List tenants with filtering\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function listTenants(options: ListTenantsOptions = {}): Promise<Tenant[]> {\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.get<Tenant[]>('/tenants', { params: options });\r\n\r\n  throw new Error('Tenants API endpoint not yet implemented in backend');\r\n}\r\n\r\n/**\r\n * Get a single tenant by ID\r\n * Note: This endpoint doesn't exist in backend yet - using stub\r\n */\r\nexport async function getTenant(options: GetTenantOptions): Promise<Tenant> {\r\n  const { tenantId } = options;\r\n\r\n  // Backend endpoint not implemented yet\r\n  // When implemented, uncomment:\r\n  // return apiClient.get<Tenant>(`/tenants/${tenantId}`);\r\n\r\n  throw new Error('Tenants API endpoint not yet implemented in backend');\r\n}\r\n","/**\r\n * State Management Hooks\r\n * React hooks for fetching data with automatic mock fallback\r\n */\r\n\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport { useAppState } from './context';\r\nimport { ApiError, NetworkError } from '@/lib/api';\r\n\r\nexport interface UseApiOptions<T> {\r\n  /**\r\n   * Function to fetch data from API\r\n   */\r\n  fetcher: () => Promise<T>;\r\n\r\n  /**\r\n   * Fallback mock data when API is unavailable\r\n   */\r\n  mockData: T;\r\n\r\n  /**\r\n   * Whether to fetch on mount (default: true)\r\n   */\r\n  enabled?: boolean;\r\n\r\n  /**\r\n   * Refetch interval in milliseconds (0 = no auto-refetch)\r\n   */\r\n  refetchInterval?: number;\r\n\r\n  /**\r\n   * Callback when data is successfully fetched\r\n   */\r\n  onSuccess?: (data: T) => void;\r\n\r\n  /**\r\n   * Callback when fetch fails\r\n   */\r\n  onError?: (error: Error) => void;\r\n}\r\n\r\nexport interface UseApiResult<T> {\r\n  /**\r\n   * The fetched or mock data\r\n   */\r\n  data: T | null;\r\n\r\n  /**\r\n   * Whether data is currently being fetched\r\n   */\r\n  isLoading: boolean;\r\n\r\n  /**\r\n   * Error from last fetch attempt\r\n   */\r\n  error: Error | null;\r\n\r\n  /**\r\n   * Whether mock data is being used\r\n   */\r\n  isUsingMock: boolean;\r\n\r\n  /**\r\n   * Manually trigger a refetch\r\n   */\r\n  refetch: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Hook for fetching data from API with automatic mock fallback\r\n */\r\nexport function useApi<T>(options: UseApiOptions<T>): UseApiResult<T> {\r\n  const {\r\n    fetcher,\r\n    mockData,\r\n    enabled = true,\r\n    refetchInterval = 0,\r\n    onSuccess,\r\n    onError,\r\n  } = options;\r\n\r\n  const { liveMode } = useAppState();\r\n\r\n  const [data, setData] = React.useState<T | null>(null);\r\n  const [isLoading, setIsLoading] = React.useState(false);\r\n  const [error, setError] = React.useState<Error | null>(null);\r\n  const [isUsingMock, setIsUsingMock] = React.useState(!liveMode);\r\n\r\n  const fetchData = React.useCallback(async () => {\r\n    if (!enabled) {\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      if (!liveMode) {\r\n        // In mock mode, use mock data\r\n        setData(mockData);\r\n        setIsUsingMock(true);\r\n        onSuccess?.(mockData);\r\n        return;\r\n      }\r\n\r\n      // In live mode, try to fetch from API\r\n      const result = await fetcher();\r\n      setData(result);\r\n      setIsUsingMock(false);\r\n      onSuccess?.(result);\r\n    } catch (err) {\r\n      const apiError = err instanceof Error ? err : new Error('Unknown error');\r\n      setError(apiError);\r\n      onError?.(apiError);\r\n\r\n      // Fallback to mock data on network errors\r\n      if (apiError instanceof NetworkError || apiError instanceof ApiError) {\r\n        console.warn('API fetch failed, using mock data:', apiError.message);\r\n        setData(mockData);\r\n        setIsUsingMock(true);\r\n      }\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [enabled, liveMode, fetcher, mockData, onSuccess, onError]);\r\n\r\n  // Initial fetch\r\n  React.useEffect(() => {\r\n    fetchData();\r\n  }, [fetchData]);\r\n\r\n  // Auto-refetch interval\r\n  React.useEffect(() => {\r\n    if (refetchInterval > 0 && enabled) {\r\n      const intervalId = setInterval(fetchData, refetchInterval);\r\n      return () => clearInterval(intervalId);\r\n    }\r\n  }, [refetchInterval, enabled, fetchData]);\r\n\r\n  return {\r\n    data,\r\n    isLoading,\r\n    error,\r\n    isUsingMock,\r\n    refetch: fetchData,\r\n  };\r\n}\r\n\r\n/**\r\n * Hook for paginated API data\r\n */\r\nexport interface UsePaginatedApiOptions<T> extends UseApiOptions<{ items: T[]; nextPageToken?: string | null }> {\r\n  /**\r\n   * Initial page size\r\n   */\r\n  pageSize?: number;\r\n}\r\n\r\nexport interface UsePaginatedApiResult<T> extends UseApiResult<{ items: T[]; nextPageToken?: string | null }> {\r\n  /**\r\n   * Load next page\r\n   */\r\n  loadMore: () => Promise<void>;\r\n\r\n  /**\r\n   * Whether more pages are available\r\n   */\r\n  hasMore: boolean;\r\n\r\n  /**\r\n   * All items loaded so far\r\n   */\r\n  items: T[];\r\n}\r\n\r\nexport function usePaginatedApi<T>(\r\n  options: UsePaginatedApiOptions<T>\r\n): UsePaginatedApiResult<T> {\r\n  const result = useApi(options);\r\n  const [allItems, setAllItems] = React.useState<T[]>([]);\r\n  const [pageToken, setPageToken] = React.useState<string | null>(null);\r\n\r\n  // Accumulate items\r\n  React.useEffect(() => {\r\n    if (result.data?.items) {\r\n      setAllItems((prev) => [...prev, ...result.data.items]);\r\n      setPageToken(result.data.nextPageToken || null);\r\n    }\r\n  }, [result.data]);\r\n\r\n  const loadMore = React.useCallback(async () => {\r\n    if (pageToken) {\r\n      await result.refetch();\r\n    }\r\n  }, [pageToken, result]);\r\n\r\n  return {\r\n    ...result,\r\n    items: allItems,\r\n    hasMore: Boolean(pageToken),\r\n    loadMore,\r\n  };\r\n}\r\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactJsxRuntime","React"],"mappings":"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","ignoreList":[0,1,2]}